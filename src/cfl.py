# Copyright 2013-2015. The Regents of the University of California.
# All rights reserved. Use of this source code is governed by 
# a BSD-style license which can be found in the LICENSE file.
#
# Authors: 
# 2013 Martin Uecker <uecker@eecs.berkeley.edu>
# 2015 Jonathan Tamir <jtamir@eecs.berkeley.edu>


IMPORT_ALL = False
import numpy as np

if IMPORT_ALL:
    try:
        import matplotlib.pyplot as plt
        from matplotlib.cm import Greys_r
    except ImportError:
        pass


def readcfl(name):
    # get dims from .hdr
    h = open(name + ".hdr", "r")
    h.readline() # skip
    l = h.readline()
    h.close()
    dims = [int(i) for i in l.split( )]

    # remove singleton dimensions from the end
    n = np.prod(dims)
    dims_prod = np.cumprod(dims)
    dims = dims[:np.searchsorted(dims_prod, n)+1]

    # load data and reshape into dims
    d = open(name + ".cfl", "r")
    a = np.fromfile(d, dtype=np.complex64, count=n);
    d.close()
    return a.reshape(dims, order='F') # column-major

	
def writecfl(name, array):
    h = open(name + ".hdr", "w")
    h.write('# Dimensions\n')
    for i in (array.shape):
            h.write("%d " % i)
    h.write('\n')
    h.close()
    d = open(name + ".cfl", "w")
    array.T.astype(np.complex64).tofile(d) # tranpose for column-major order
    d.close()


def cfl2sqcfl(cfl, e2s):
  """ This squeezes the cfl images and skips the needed echo times. """
  return cfl[0, :, :, 0, 0, e2s:]


def sqcfl2mat(sqcfl):
  """ Converts a squeezed cfl image to a matrix of pixel intensities with
      each column representing a single pixel and each row representing 
      its intensity after 1 TE. This returns the constructed matrix and
      the dimensions of the original image. """
  m, n, T = sqcfl.shape
  X = np.zeros((T, m * n), dtype=np.complex64)
  for r in range(m):
    for c in range(n):
      X[:, c + r * n] = sqcfl[r, c, :]
  return np.matrix(X), (m, n)


def mat2sqcfl(mat, dim):
  """ This converts a matrix generated by sqcfl2mat back to sqcfl. """
  m, n = dim  
  T    = mat.shape[0]
  cfl = np.zeros((m, n, T))
  for t in range(T):
    for r in range(m):
      cfl[r, :, t] = mat[t, r * n: (r + 1) * n]
  return cfl


def disp_sqcfl(sqcfl):
  print "n - next, p - prev, e - escape"
  fig = plt.figure() 
  ctr = 0
  T = sqcfl.shape[2]
  while plt.fignum_exists(fig.number): 
    plt.imshow(abs(sqcfl[:, :, ctr]), cmap = Greys_r) 
    k = raw_input('Enter command: ') 
    if k == 'n':
      ctr += 1
    elif k == 'p':
      ctr -= 1
    elif k == 'e':
      break
    ctr = ctr % T
